start = statement+
statement = ws s:(var / function / class / expression ) ws
	  { return s }

var = 'var' s:symbol t:type? a:varAssingment?
    { return { type: 'var', name: s, typeExpression: t, assingment: a } }

type = ':' ws t:typeExpression ws
     { return t }

typeExpression = typeConstructor / typeStruct / typeFunction

typeFunction = '(' p:typeList? ')' ws '->' r:typeExpression
	     { return { type: 'functionType', parameters: p === '' ? [] : p, returnType: r }}

typeList = t:typeExpression tt:typeListTail*
	 { return [t].concat(tt) }

typeListTail = ',' t:typeExpression
	     { return t }

typeStruct = '{' t:typeFields? '}'
	   { return { type: 'structType', fields: t } }

typeFields = t:typeField ts:typeFieldTail*
	   { return [t].concat(ts) }

typeFieldTail = ',' t:typeField
	      { return t }

typeField =  k:key ':' t:typeExpression
	  { return { key: k, value: t }}

typeConstructor = s:symbol a:typeArguments?
	       { return { type: 'constructorType', constructor: s, args: a === '' ? [] : a }}

typeArguments = '<' t:typeExpression ts:typeArgumentTail* '>'
	 { return [t].concat(ts) }

typeArgumentTail = ',' t:typeExpression
	    { return t }

varAssingment = '=' e:expression
	      { return e }

function = i:symbol p:parameterList body:block
	 { return { type: 'function', parameters: p, body: body, name: i} }

block = ws '{' s:statement* '}' ws
      { return s }

parameterList = '(' p:parameters? ')'
	      { return p === '' ? [] : p }

parameters = p:parameter ps:parameterListTail*
	   { return [p].concat(ps) }

parameterListTail = ',' p:parameter
		  { return p }

parameter = s:symbol t:type?
	  { return { type: 'parameter', symbol: s, typeExpression: t === '' ? undefined : t } }

symbol = ws i:[a-zA-Z_$] is:[a-zA-Z_0-9$]* ws
       { return i + is.join('')}

identifier = s:symbol
	   { return { type: 'identifier', name: s } }

class = 'class' i:symbol '{' ifs:interface* '}'
      { return { type: 'class', name: 'i', interfaces: ifs }}

interface = ws p:('public')? i:(function / identifier) ws
	  { return { visibility: p ? 'public' : 'private', interface: i}}

arguments = e:expression args:argumentTail*
	  { return [e].concat([args]) }

argumentTail = ',' e:expression
	     { return e }

expression = ws e:(application / assingment / operation / terminal / parenthesis / lambda / array / struct) ws
	   { return e }

application = t:terminal '(' args:arguments? ')'
	    { return { type: 'application', callee: t, arguments: args }}

assingment = t:terminal '=' e:expression
	   { return { type: 'assingment', lhs: t, rhs: e }}

operation = lhs: terminal op:op rhs:expression
	  { return { type: 'operation', lhs: lhs, rhs: rhs, operation: op }}

parenthesis = '(' e:expression ')'
	    { return { type: 'parenthesis', expression: e }}

terminal = literal / identifier

lambda = ps:parameterList body:block
       { return { type: 'function', parameters:ps, body: body }}

op = o:[.\-+*%/]+
   { return o.join('') }

ws = [ \n\t]*

struct = '{' f:fields? '}'
       { return { type: 'struct', value: f ? f : [] } }

fields = f:field fs:fieldTail*
       { return [f].concat(fs) }

fieldTail = ',' f:field
	  { return f }

field = k:key ':' v:expression
      { return {key: k, value: v} }

key = symbol / stringSymbol

array = '[' e:expression es:expressionTail* ']'
      { return { type: 'array', value: [e].concat(es)} }

expressionTail = ',' e:expression
	       { return e }

literal = ws lit:(number / string) ws
	{ return lit }

number = v:[0-9]+ vs:('.' [0-9]+)?
       { return { type: 'number', value: v.concat(vs ? '.' + vs[1].join('') : []).join('') } }

string = s:stringSymbol
       { return { type: 'string', value: s }}

stringSymbol = ws '"' s:([^"]*) '"' ws
	     { return s.join('') }